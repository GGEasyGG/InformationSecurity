# Практическое задание по курсу “Теоретико–кодовые конструкции в криптографии” (1-ый вариант)

## Структура проекта

1. `src/ISD.jl` - файл, содержащий функцию `decodeISD`;
2. `src/STERN.jl` - файл, содержащий функцию `decodeSTERN` и вспомогательные функции (функция `decodeSTERN_for_analysis` является полной копией функции `decodeSTERN` с той лишь разницей,
что при успешном нахождении решения дополнительно возвращает количество итераций, затраченное на поиск этого решения; не является основной и используется исключительно для анализа параметров алгоритма Штерна);
3. `src/utils/linear_algebra_utils.jl` - файл, содержащий функции для `LUP` разложения матрицы и поиска определителя и обратной матрицы по этому разложению;
4. `src/utils/tests_utils.jl` - файл, содержащий вспомогательные функции для проведения тестов и экспериментов;
5. `tests/tests.jl` - файл, содержащий тесты для проверки функций `decodeISD` и `decodeSTERN` (команда запуска - `julia tests/tests.jl`);
6. `experiments/test_time.jl` - файл для проведения экспериментов по сравнению времени работы `decodeISD` и `decodeSTERN`;
7. `experiments/p_and_l_analysis.jl` - файл для проведения экспериментов по анализу параметров алгоритма Штерна;
8. `experiments/results` - директория, содержащая в виде `.csv` файлов результаты экспериментов по сравнению времени работы `decodeISD` и `decodeSTERN`, а также по анализу параметров алгоритма Штерна;

## Руководство по использованию функций `decodeISD` и `decodeSTERN` и форматам данных

### Функция `decodeISD`

Для использования функции требуется подключить файл с ней в качестве модуля.

Функция `decodeISD` принимает на вход:

1. $G \in F^{k \times n}_{2}$ - матрицу размера ($k \times n$), состоящую из элементов поля $F_{2}$;
2. $y \in F^{n}_{2}$ - вектор длины $n$;
3. $t \in N$ - натуральное число;
4. $niter \in N$ - натуральное число, равное максимальному числу итераций (по умолчанию равно -1).

Функция `decodeISD` возвращает пару таких векторов ($m \in F^{k}$, $e \in F^{n}$), что $y = m \cdot G + e$ и $wt(e) = t$, либо $niter$, если таких векторов найти не удалось.

### Функция `decodeSTERN`

Для использования функции требуется подключить файл с ней в качестве модуля.

Функция `decodeSTERN` принимает на вход:

1. $H \in F^{r \times n}_{2}$ - матрицу размера ($r \times n$), состоящую из элементов поля $F_{2}$;
2. $s \in F^{r}_{2}$ - вектор длины $r$;
3. $t \in N$ - натуральное число;
4. ($p \in N$, $l \in N$) - набора параметров алгоритма Штерна;
5. $niter \in N$ - натуральное число, равное максимальному числу итераций (по умолчанию равно -1).

Функция `decodeSTERN` возвращает такой вектор $e \in F^{n}$, что $s^{T} = H \cdot e^{T}$ и $wt(e) = t$, либо $niter$, если таких векторов найти не удалось.

## Отчёт

### Сравнение скоростей работы алгоритма Штерна и декодирования с использованием информационных множеств

#### Сравнение скоростей работы одной итерации

Под каждую пару `(k, n)` генерировалась матрица `G` и вектор `y`, для которых под заданные значения `t` алгоритм декодирования с использованием информационных множеств не может найти решение за `10` итераций.
По матрице `G` и вектору `y` строились матрица `H` и вектор `s`; параметры `p` и `l` устанавливались в значение `1` и `2` соответственно; проверялось, что алгоритм Штерна под заданные значения `t` также не может найти решение за `10` итераций.

Для замеров алгоритмы запускались на входных значениях, описанных выше, и с числом итераций, равным `10`. Усреднение замеров производилось по `100` запускам.

|k  |n  |t  |ISD_time (s)          |STERN_time (s)        |
|---|---|---|----------------------|----------------------|
|16 |64 |4  |7.213298399999998e-5  |0.001682805675        |
|16 |64 |8  |7.550343200000002e-5  |0.0016381333460000007 |
|16 |64 |16 |7.527206900000003e-5  |0.0015954306580000005 |
|16 |64 |32 |8.378672899999999e-5  |0.0011274428129999996 |
|24 |64 |4  |0.0002268501149999999 |0.0011058401430000002 |
|24 |64 |8  |0.00024300182499999994|0.001107622308        |
|24 |64 |16 |0.00022790911         |0.0005288917469999999 |
|24 |64 |32 |0.00023033272299999996|0.0011001143919999999 |
|32 |64 |4  |0.0005042609680000001 |0.0007073617169999998 |
|32 |64 |8  |0.0005281286900000002 |0.0006917042949999996 |
|32 |64 |16 |0.00044451340799999995|0.0002358809250000001 |
|32 |64 |32 |0.0005443306849999996 |0.000675349066        |
|40 |64 |4  |0.0009037021249999999 |0.0004250003460000001 |
|40 |64 |8  |0.0008859662570000002 |0.00020838490599999997|
|40 |64 |16 |0.000885624935        |0.00011615063100000002|
|40 |64 |32 |0.0009110809439999998 |0.00039479814         |
|48 |64 |4  |0.0013879003620000001 |0.00019703775000000004|
|48 |64 |8  |0.0011537419200000002 |6.568144399999998e-5  |
|48 |64 |16 |0.0014306012480000004 |0.00018677588900000003|
|48 |64 |32 |0.0014159531880000005 |0.00025280327999999987|

Как можно заметить из таблицы, при `k = n / 2` времена работы одной итерации обоих алгоритмов почти совпадают (с точностью до погрешности измерения).
При уменьшении k относительно значения `n / 2` алгоритм декодирования с использованием информационных множеств начинает показывать лучшее время работы по сравнению с алгоритмом Штерна.
При увеличении k относительно значения `n / 2` алгоритм декодирования с использованием информационных множеств начинает показывать худшее время работы по сравнению с алгоритмом Штерна.

#### Сравнение скоростей нахождения решения

Под каждую пару `(k, n)` генерировалась матрица `G` и вектор `y`, для которых под заданные значения `t` алгоритм декодирования с использованием информационных множеств находит решение за `10000` итераций.
По матрице `G` и вектору `y` строились матрица `H` и вектор `s`; параметры `p` и `l` устанавливались в значение `1` и `2` соответственно; проверялось, что алгоритм Штерна под заданные значения `t` также находит решение за `10000` итераций.

Для замеров алгоритмы запускались на входных значениях, описанных выше, и с "бесконечным" числом итераций. Усреднение замеров производилось по `100` запускам.

|k  |n  |t  |ISD_time (s)          |STERN_time (s)        |
|---|---|---|----------------------|----------------------|
|48 |128|24 |39.956010069310004    |5.706260328259998     |
|48 |128|28 |2.4032335839899988    |0.2529390954600001    |
|48 |128|32 |0.3555080297899999    |0.035629251820000006  |
|48 |128|36 |0.11184983772999998   |0.023610056429999998  |
|64 |128|24 |0.9728406622099999    |0.022611607989999984  |
|64 |128|28 |0.23045114792         |0.01576285203         |
|64 |128|32 |0.12606725175999997   |0.013635646119999997  |
|64 |128|36 |0.23871312779         |0.014986247290000006  |
|80 |128|24 |0.19570305314000003   |0.007028588429999995  |
|80 |128|28 |0.3318551955499999    |0.007635217089999999  |
|80 |128|32 |2.6173671382299997    |0.006974757580000001  |
|80 |128|36 |76.90613062208999     |0.015185152479999988  |

Как можно заметить из таблицы, алгоритм Штерна во всех случаях показывает лучшее время работы по сравнению с алгоритмом декодирования с использованием информационных множеств.

### Анализ поведения алгоритма Штерна для различных значений его параметров

Замеры производились при `k = 32`, `n = 64` и `t = 16`. Под эти значения генерировалась матрица `G` и вектор `y`, для которых алгоритм декодирования с использованием информационных множеств находит решение за `10000` итераций.
По матрице `G` и вектору `y` строились матрица `H` и вектор `s`; параметры `p` и `l` устанавливались в значение `1` и `1` соответственно; проверялось, что алгоритм Штерна под заданные значения параметров также находит решение за `10000` итераций.

Для замеров алгоритмы запускались на входных значениях, описанных выше, на параметрах `p` и `l`, указанных в таблице, и с "бесконечным" числом итераций. Усреднение замеров производилось по `100` запускам.

|p  |l  |time (s)             |iterations|
|---|---|---------------------|----------|
|1  |1  |0.0026665711402893066|3.4       |
|2  |1  |0.009633815288543702 |3.31      |
|4  |1  |2.0855667090415952   |3.17      |
|6  |1  |47.04267549276352    |4.21      |
|1  |1  |0.0023609733581542967|3.29      |
|1  |2  |0.0025207304954528807|3.66      |
|1  |4  |0.0026346421241760253|3.64      |
|1  |8  |0.038068833351135256 |37.02     |
|1  |16 |6.2651704621315005   |8390.08   |

Увеличение значения `p` увеличивает количество комбинаций для проверки, что, в свою очередь, увеличивает время выполнения.
Увеличение значения `l` увеличивает специфичность сопоставления, но также увеличивает и вычислительные затраты.
